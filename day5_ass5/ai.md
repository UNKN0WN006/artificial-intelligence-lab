Explanation of the Question:

You are given a classic AI search problem:
A farmer needs to transport a wolf, a goat, and a cabbage across a river using a boat that can only carry the farmer and one other item at a time. The constraints are:

The wolf cannot be left alone with the goat (wolf eats goat).
The goat cannot be left alone with the cabbage (goat eats cabbage).
Only the farmer can row the boat.
Your Tasks:

Implement Multiple Search Algorithms:
Solve the problem using BFS, DFS, DLS (with 3 depths), IDS (with 3 depths), ILS, and UCS.

Parameterization:
All parameters (like depth limits, costs, initial/final states) must be provided via input files (not hardcoded).

Logging and Output:

Log intermediate steps and final solutions to output/log files.
Measure and record time and memory usage for each run.
Comparison and Visualization:

Compare algorithms (and different parameters for DLS/IDS) in a table for time and memory.
Create 4 plots: 2 for memory, 2 for time (comparing algorithms and/or parameter settings).
Documentation:

Document the format of input files.
Provide a write-up of your approach.
Submission:

Upload Colab notebook, all input/output files, and your write-up.
Summary:
You must solve the river crossing problem using several search algorithms, parameterized via input files, and compare their performance in terms of time and memory, documenting everything and visualizing the results.

Restore Checkpoint


Here’s a breakdown based on your assignment requirements:

1. Notebook Files
1 Colab/Jupyter Notebook (.ipynb):
This will contain your code, explanations, and plots.
2. Input Files
1 input file per algorithm (since each may need different parameters):
BFS: input_bfs.txt
DFS: input_dfs.txt
DLS: input_dls.txt
IDS: input_ids.txt
ILS: input_ils.txt
UCS: input_ucs.txt
Total input files: 6
3. Output/Log Files
1 output/log file per algorithm (to store intermediate and final outputs):
BFS: output_bfs.txt
DFS: output_dfs.txt
DLS: output_dls.txt
IDS: output_ids.txt
ILS: output_ils.txt
UCS: output_ucs.txt
Total output files: 6
4. Plots
4 plots required:
2 for memory comparison (e.g., bar/line plots)
2 for time comparison
5. Summary Table
1 comparison table (can be in the notebook or as a CSV/Markdown table)
Summary Table:

File Type	Count	Example Names
Notebook	1	missionaries_lab.ipynb
Input files	6	input_bfs.txt, ...
Output files	6	output_bfs.txt, ...
Plots	4	(in notebook, as images)
Table	1	(in notebook)
Total files to upload:

1 notebook
6 input files
6 output files
(Plots and table are inside the notebook)
Let me know if you want templates for the input/output files!

Restore Checkpoint


Intermediate output refers to the step-by-step progress or states generated by your algorithm as it searches for a solution, not just the final answer.

For example, in the context of search algorithms:

The sequence of states visited (e.g., which nodes/states are expanded at each step)
The contents of the frontier/queue/stack at each step
The path being constructed so far
Any pruning or backtracking events
Why is it needed?
It helps to:

Debug and understand how your algorithm works
Show the process, not just the result
How to log it?
Write these details to your output/log file as your algorithm runs, before writing the final solution.

Example (for BFS):


Step 1: Expanding state: (F, W, G, C, Left)Frontier: [(F, W, G, C, Right), ...]Step 2: Expanding state: (F, G, C, Right)Frontier: [...]...Final Solution: [sequence of moves]
Summary:
Intermediate output = all the important steps and decisions your algorithm makes before reaching the solution.


To provide intermediate outputs for your search algorithms, follow these steps:

1. Log Steps During Execution
Inside your algorithm’s main loop (e.g., while expanding nodes), write details such as:

Current state being expanded
Frontier/queue/stack contents
Path so far
Any pruning/backtracking
2. Write to Output/Log File
Open a log file (e.g., output_bfs.txt) in append mode and write each step as you process it.

Example in Python:

# ...existing code...with open('output_bfs.txt', 'w') as log:    step = 0    while frontier:        state = frontier.pop(0)        log.write(f"Step {step}: Expanding state: {state}\n")        log.write(f"Frontier: {frontier}\n")        # ...expand state, add new states to frontier...        step += 1# ...existing code...
3. Repeat for Each Algorithm
Do the same for DFS, DLS, IDS, ILS, UCS, each writing to their respective output/log files.

4. Include Final Solution
At the end, write the final solution path and stats (time, memory) to the same file.

Summary:

Log each step’s details to a file as your algorithm runs.
This file will contain both intermediate and final outputs.
Restore Checkpoint
